<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://botkit.ai"

    >botkit (v0.5.2)</a>
</h1>
<h4>Building blocks for Building Bots</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.botkit">module botkit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.botkit.botframeworkbot">
            function <span class="apidocSignatureSpan">botkit.</span>botframeworkbot
            <span class="apidocSignatureSpan">(configuration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.botkit.consolebot">
            function <span class="apidocSignatureSpan">botkit.</span>consolebot
            <span class="apidocSignatureSpan">(configuration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.botkit.core">
            function <span class="apidocSignatureSpan">botkit.</span>core
            <span class="apidocSignatureSpan">(configuration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.botkit.facebookbot">
            function <span class="apidocSignatureSpan">botkit.</span>facebookbot
            <span class="apidocSignatureSpan">(configuration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.botkit.slackbot">
            function <span class="apidocSignatureSpan">botkit.</span>slackbot
            <span class="apidocSignatureSpan">(configuration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.botkit.sparkbot">
            function <span class="apidocSignatureSpan">botkit.</span>sparkbot
            <span class="apidocSignatureSpan">(configuration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.botkit.twilioipmbot">
            function <span class="apidocSignatureSpan">botkit.</span>twilioipmbot
            <span class="apidocSignatureSpan">(configuration)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.botkit" id="apidoc.module.botkit">module botkit</a></h1>


    <h2>
        <a href="#apidoc.element.botkit.botframeworkbot" id="apidoc.element.botkit.botframeworkbot">
        function <span class="apidocSignatureSpan">botkit.</span>botframeworkbot
        <span class="apidocSignatureSpan">(configuration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BotFrameworkBot(configuration) {

    // Create a core botkit bot
    var bf_botkit = Botkit(configuration || {});

    // customize the bot definition, which will be used when new connections
    // spawn!
    bf_botkit.defineBot(function(botkit, config) {

        var bot = {
            botkit: botkit,
            config: config || {},
            utterances: botkit.utterances,
        };

        bot.startConversation = function(message, cb) {
            botkit.startConversation(this, message, cb);
        };

        bot.send = function(message, cb) {
            function done(err) {
                if (cb) {
                    cb(err);
                }
            }

            if (!message || !message.address) {
                if (cb) {
                    cb(new Error(&#x27;Outgoing message requires a valid address...&#x27;));
                }
                return;
            }

            // Copy message minus user &#x26; channel fields
            var bf_message = {};
            for (var key in message) {
                switch (key) {
                    case &#x27;user&#x27;:
                    case &#x27;channel&#x27;:
                        // ignore
                        break;
                    default:
                        bf_message[key] = message[key];
                        break;
                }
            }
            if (!bf_message.type) {
                bf_message.type = &#x27;message&#x27;;
            }

            // Ensure the message address has a valid conversation id.
            if (!bf_message.address.conversation) {
                bot.connector.startConversation(bf_message.address, function(err, adr) {
                    if (!err) {
                        // Send message through connector
                        bf_message.address = adr;
                        bot.connector.send([bf_message], done);
                    } else {
                        done(err);
                    }
                });
            } else {
                // Send message through connector
                bot.connector.send([bf_message], done);
            }
        };

        bot.reply = function(src, resp, cb) {
            var msg = {};

            if (typeof(resp) == &#x27;string&#x27;) {
                msg.text = resp;
            } else {
                msg = resp;
            }

            msg.user = src.user;
            msg.channel = src.channel;
            msg.address = src.address;

            bot.say(msg, cb);
        };

        bot.findConversation = function(message, cb) {
            botkit.debug(&#x27;CUSTOM FIND CONVO&#x27;, message.user, message.channel);
            for (var t = 0; t &#x3c; botkit.tasks.length; t++) {
                for (var c = 0; c &#x3c; botkit.tasks[t].convos.length; c++) {
                    if (
                        botkit.tasks[t].convos[c].isActive() &#x26;&#x26;
                        botkit.tasks[t].convos[c].source_message.user == message.user &#x26;&#x26;
                        botkit.tasks[t].convos[c].source_message.channel == message.channel
                    ) {
                        botkit.debug(&#x27;FOUND EXISTING CONVO!&#x27;);
                        cb(botkit.tasks[t].convos[c]);
                        return;
                    }
                }
            }

            cb();
        };

        // Create connector
        bot.connector = new builder.ChatConnector(config);

        return bot;

    });


    // set up a web route for receiving outgoing webhooks and/or slash commands

    bf_botkit.createWebhookEndpoints = function(webserver, bot, cb) {

        // Listen for incoming events
        bf_botkit.log(
            &#x27;** Serving webhook endpoints for the Microsoft Bot Framework at: &#x27; +
                &#x27;http://&#x27; + bf_botkit.config.hostname + &#x27;:&#x27; +
                bf_botkit.config.port + &#x27;/botframework/receive&#x27;);
        webserver.post(&#x27;/botframework/receive&#x27;, bot.connector.listen());

        // Receive events from chat connector
        bot.connector.onEvent(function(events, done) {
            for (var i = 0; i &#x3c; events.length; i++) {
                // Break out user &#x26; chann ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

To connect your bot to the Bot Framework follow the step by step guide outlined in [Getting Started](#getting-started).

Here is the complete code for a basic Bot Framework bot:

```javascript
var Botkit = require(&#x27;botkit&#x27;);
var controller = Botkit.<span class="apidocCodeKeywordSpan">botframeworkbot</span>({
});

var bot = controller.spawn({
        appId: process.env.app_id,
        appPassword: process.env.app_password
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.botkit.consolebot" id="apidoc.element.botkit.consolebot">
        function <span class="apidocSignatureSpan">botkit.</span>consolebot
        <span class="apidocSignatureSpan">(configuration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TextBot(configuration) {

    // Create a core botkit bot
    var text_botkit = Botkit(configuration || {});


    text_botkit.middleware.spawn.use(function(bot, next) {

        text_botkit.listenStdIn(bot);
        next();

    });

    text_botkit.defineBot(function(botkit, config) {

        var bot = {
            botkit: botkit,
            config: config || {},
            utterances: botkit.utterances,
        };

        bot.startConversation = function(message, cb) {
            botkit.startConversation(this, message, cb);
        };

        bot.send = function(message, cb) {
            console.log(&#x27;BOT:&#x27;, message.text);
        };

        bot.reply = function(src, resp, cb) {
            var msg = {};

            if (typeof(resp) == &#x27;string&#x27;) {
                msg.text = resp;
            } else {
                msg = resp;
            }

            msg.channel = src.channel;

            bot.say(msg, cb);
        };

        bot.findConversation = function(message, cb) {
            botkit.debug(&#x27;CUSTOM FIND CONVO&#x27;, message.user, message.channel);
            for (var t = 0; t &#x3c; botkit.tasks.length; t++) {
                for (var c = 0; c &#x3c; botkit.tasks[t].convos.length; c++) {
                    if (
                        botkit.tasks[t].convos[c].isActive() &#x26;&#x26;
                        botkit.tasks[t].convos[c].source_message.user == message.user
                    ) {
                        botkit.debug(&#x27;FOUND EXISTING CONVO!&#x27;);
                        cb(botkit.tasks[t].convos[c]);
                        return;
                    }
                }
            }

            cb();
        };

        return bot;

    });

    text_botkit.listenStdIn = function(bot) {

        text_botkit.startTicking();
        var rl = readline.createInterface({ input: process.stdin, output: process.stdout, terminal: false });
        rl.on(&#x27;line&#x27;, function(line) {
            var message = {
                text: line,
                user: &#x27;user&#x27;,
                channel: &#x27;text&#x27;,
                timestamp: Date.now()
            };
            text_botkit.receiveMessage(bot, message);
        });
    };

    return text_botkit;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.botkit.core" id="apidoc.element.botkit.core">
        function <span class="apidocSignatureSpan">botkit.</span>core
        <span class="apidocSignatureSpan">(configuration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Botkit(configuration) {
    var botkit = {
        events: {}, // this will hold event handlers
        config: {}, // this will hold the configuration
        tasks: [],
        taskCount: 0,
        convoCount: 0,
        my_version: null,
        my_user_agent: null,
        memory_store: {
            users: {},
            channels: {},
            teams: {},
        }
    };

    botkit.utterances = {
        yes: new RegExp(/^(yes|yea|yup|yep|ya|sure|ok|y|yeah|yah)/i),
        no: new RegExp(/^(no|nah|nope|n)/i),
        quit: new RegExp(/^(quit|cancel|end|stop|done|exit|nevermind|never mind)/i)
    };

    // define some middleware points where custom functions
    // can plug into key points of botkits process
    botkit.middleware = {
        send: ware(),
        receive: ware(),
        spawn: ware(),
        heard: ware(),
        capture: ware(),
    };


    function Conversation(task, message) {

        this.messages = [];
        this.sent = [];
        this.transcript = [];

        this.context = {
            user: message.user,
            channel: message.channel,
            bot: task.bot,
        };

        this.events = {};

        this.vars = {};

        this.threads = {};
        this.thread = null;

        this.status = &#x27;new&#x27;;
        this.task = task;
        this.source_message = message;
        this.handler = null;
        this.responses = {};
        this.capture_options = {};
        this.startTime = new Date();
        this.lastActive = new Date();

        this.collectResponse = function(key, value) {
            this.responses[key] = value;
        };

        this.capture = function(response, cb) {

            var that = this;
            var capture_key = this.sent[this.sent.length - 1].text;
            botkit.middleware.capture.run(that.task.bot, response, that, function(err, bot, response, convo) {
                if (response.text) {
                    response.text = response.text.trim();
                } else {
                    response.text = &#x27;&#x27;;
                }

                if (that.capture_options.key != undefined) {
                    capture_key = that.capture_options.key;
                }

                // capture the question that was asked
                // if text is an array, get 1st
                if (typeof(that.sent[that.sent.length - 1].text) == &#x27;string&#x27;) {
                    response.question = that.sent[that.sent.length - 1].text;
                } else if (Array.isArray(that.sent[that.sent.length - 1].text)) {
                    response.question = that.sent[that.sent.length - 1].text[0];
                } else {
                    response.question = &#x27;&#x27;;
                }

                if (that.capture_options.multiple) {
                    if (!that.responses[capture_key]) {
                        that.responses[capture_key] = [];
                    }
                    that.responses[capture_key].push(response);
                } else {
                    that.responses[capture_key] = response;
                }

                if (cb) cb(response);
            });

        };

        this.handle = function(message) {

            that = this;
            this.lastActive = new Date();
            this.transcript.push(message);
            botkit.debug(&#x27;HANDLING MESSAGE IN CONVO&#x27;, message);
            // do other stuff like call custom callbacks
            if (this.handler) {
                this.capture(message, function(message) {
                    // if the handler is a normal function, just execute it!
                    // NOTE: anyone who passes in their own handler has to call
                    // convo.next() to continue after completing whatever it is they want to do.
                    if (typeof(that.handler) == &#x27;function&#x27;) {
                        that.handler(message, that);
                    } else {
                        // handle might be a mapping of keyword to callback.
                        // lets see if the message matches any of the keywords
                        var match, p ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.botkit.facebookbot" id="apidoc.element.botkit.facebookbot">
        function <span class="apidocSignatureSpan">botkit.</span>facebookbot
        <span class="apidocSignatureSpan">(configuration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Facebookbot(configuration) {

    var api_host = configuration.api_host || &#x27;graph.facebook.com&#x27;;

    // Create a core botkit bot
    var facebook_botkit = Botkit(configuration || {});

    if (facebook_botkit.config.require_delivery) {

        facebook_botkit.on(&#x27;message_delivered&#x27;, function(bot, message) {

            // get list of mids in this message
            for (var m = 0; m &#x3c; message.delivery.mids.length; m++) {
                var mid = message.delivery.mids[m];

                // loop through all active conversations this bot is having
                // and mark messages in conversations as delivered = true
                bot.findConversation(message, function(convo) {
                    if (convo) {
                        for (var s = 0; s &#x3c; convo.sent.length; s++) {
                            if (convo.sent[s].sent_timestamp &#x3c;= message.delivery.watermark ||
                                (convo.sent[s].api_response &#x26;&#x26; convo.sent[s].api_response.mid == mid)) {
                                convo.sent[s].delivered = true;
                            }
                        }
                    }
                });
            }

        });

    }

    // customize the bot definition, which will be used when new connections
    // spawn!
    facebook_botkit.defineBot(function(botkit, config) {

        var bot = {
            type: &#x27;fb&#x27;,
            botkit: botkit,
            config: config || {},
            utterances: botkit.utterances,
        };

        bot.startConversation = function(message, cb) {
            botkit.startConversation(this, message, cb);
        };

        bot.createConversation = function(message, cb) {
            botkit.createConversation(this, message, cb);
        };


        bot.send = function(message, cb) {

            var facebook_message = {
                recipient: {},
                message: message.sender_action ? undefined : {}
            };

            if (typeof(message.channel) == &#x27;string&#x27; &#x26;&#x26; message.channel.match(/\+\d+\(\d\d\d\)\d\d\d\-\d\d\d\d/)) {
                facebook_message.recipient.phone_number = message.channel;
            } else {
                facebook_message.recipient.id = message.channel;
            }

            if (!message.sender_action) {
                if (message.text) {
                    facebook_message.message.text = message.text;
                }

                if (message.attachment) {
                    facebook_message.message.attachment = message.attachment;
                }

                if (message.sticker_id) {
                    facebook_message.message.sticker_id = message.sticker_id;
                }

                if (message.quick_replies) {

                    // sanitize the length of the title to maximum of 20 chars
                    var titleLimit = function(title) {
                        if (title.length &#x3e; 20) {
                            var newTitle = title.substring(0, 16) + &#x27;...&#x27;;
                            return newTitle;
                        } else {
                            return title;
                        }
                    };

                    facebook_message.message.quick_replies = message.quick_replies.map(function(item) {
                        var quick_reply = {};
                        if (item.content_type === &#x27;text&#x27; || !item.content_type) {
                            quick_reply = {
                                content_type: &#x27;text&#x27;,
                                title: titleLimit(item.title),
                                payload: item.payload,
                                image_url: item.image_url,
                            };
                        } else if (item.content_type === &#x27;location&#x27;) {
                            quick_reply = {
                                content_type: &#x27;location&#x27;
                            };
                        } else {
                            // Future quick replies types
                        }
                        return quick_reply;
                    }); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

To connect your bot to Facebook, [follow the instructions here](https://developers.facebook.com/docs/messenger-platform/implementation
). You will need to collect your `page token` as well as a `verify token` that you define yourself and configure inside Facebook
&#x27;s app settings. A step by step guide [can be found here](#getting-started). Since you must *already be running* your Botkit
 app to configure your Facebook app, there is a bit of back-and-forth. It&#x27;s ok! You can do it.

Here is the complete code for a basic Facebook bot:

```javascript
var Botkit = require(&#x27;botkit&#x27;);
var controller = Botkit.<span class="apidocCodeKeywordSpan">facebookbot</span>({
        access_token: process.env.access_token,
        verify_token: process.env.verify_token,
})

var bot = controller.spawn({
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.botkit.slackbot" id="apidoc.element.botkit.slackbot">
        function <span class="apidocSignatureSpan">botkit.</span>slackbot
        <span class="apidocSignatureSpan">(configuration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Slackbot(configuration) {

    // Create a core botkit bot
    var slack_botkit = Botkit(configuration || {});

    // Set some default configurations unless they&#x27;ve already been set.

    // Should the RTM connections ingest received messages
    // Developers using the new Events API will set this to false
    // This allows an RTM connection to be kept alive (so bot appears online)
    // but receive messages only via events api
    if (slack_botkit.config.rtm_receive_messages === undefined) {
        slack_botkit.config.rtm_receive_messages = true;
    }

    var spawned_bots = [];

    // customize the bot definition, which will be used when new connections
    // spawn!
    slack_botkit.defineBot(require(__dirname + &#x27;/Slackbot_worker.js&#x27;));

    // Middleware to track spawned bots and connect existing RTM bots to incoming webhooks
    slack_botkit.middleware.spawn.use(function(worker, next) {

        // lets first check and make sure we don&#x27;t already have a bot
        // for this team! If we already have an RTM connection, copy it
        // into the new bot so it can be used for replies.

        var existing_bot = null;
        if (worker.config.id) {
            for (var b = 0; b &#x3c; spawned_bots.length; b++) {
                if (spawned_bots[b].config.id) {
                    if (spawned_bots[b].config.id == worker.config.id) {
                        // WAIT! We already have a bot spawned here.
                        // so instead of using the new one, use the exist one.
                        existing_bot = spawned_bots[b];
                    }
                }
            }
        }

        if (!existing_bot &#x26;&#x26; worker.config.id) {
            spawned_bots.push(worker);
        } else if (existing_bot) {
            if (existing_bot.rtm) {
                worker.rtm = existing_bot.rtm;
            }
        }
        next();

    });



    // set up configuration for oauth
    // slack_app_config should contain
    // { clientId, clientSecret, scopes}
    // https://api.slack.com/docs/oauth-scopes
    slack_botkit.configureSlackApp = function(slack_app_config, cb) {

        slack_botkit.log(&#x27;** Configuring app as a Slack App!&#x27;);
        if (!slack_app_config || !slack_app_config.clientId ||
            !slack_app_config.clientSecret || !slack_app_config.scopes) {
            throw new Error(&#x27;Missing oauth config details&#x27;);
        } else {
            slack_botkit.config.clientId = slack_app_config.clientId;
            slack_botkit.config.clientSecret = slack_app_config.clientSecret;
            if (slack_app_config.redirectUri) slack_botkit.config.redirectUri = slack_app_config.redirectUri;
            if (typeof(slack_app_config.scopes) == &#x27;string&#x27;) {
                slack_botkit.config.scopes = slack_app_config.scopes.split(/\,/);
            } else {
                slack_botkit.config.scopes = slack_app_config.scopes;
            }
            if (cb) cb(null);
        }

        return slack_botkit;

    };

    // set up a web route that is a landing page
    slack_botkit.createHomepageEndpoint = function(webserver) {

        slack_botkit.log(&#x27;** Serving app landing page at : http://&#x27; +
            slack_botkit.config.hostname + &#x27;:&#x27; + slack_botkit.config.port + &#x27;/&#x27;);

        // FIX THIS!!!
        // this is obvs not right.
        webserver.get(&#x27;/&#x27;, function(req, res) {

            res.send(&#x27;Howdy!&#x27;);

        });

        return slack_botkit;

    };


    // adds the webhook authentication middleware module to the webserver
    function secureWebhookEndpoints() {
        var authenticationMiddleware = require(__dirname + &#x27;/middleware/slack_authentication.js&#x27;);
        // convert a variable argument list to an array, drop the webserver argument
        var tokens = Array.prototype.slice.call(arguments);
        var webserver = tokens.shift();

        slack_botkit.log(
            &#x27;** Requiring token authentication for webhook endpoints for Slash commands &#x27; +
            &#x27;and outgoing webhooks; configured &#x27; + tokens.length + &#x27; token(s)&#x27;
        );

        webserver.use(authent ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Then pass the returned storage when creating your Botkit controller. Botkit will do the rest.

Make sure everything you store has an `id` property, that&#x27;s what you&#x27;ll use to look it up later.

```javascript
var Botkit = require(&#x27;botkit&#x27;),
    mongoStorage = require(&#x27;botkit-storage-mongo&#x27;)({mongoUri: &#x27;...&#x27;}),
    controller = Botkit.<span class="apidocCodeKeywordSpan">slackbot</span>({
        storage: mongoStorage
    });
```

```javascript
// then you can use the Botkit storage api, make sure you have an id property
var beans = {id: &#x27;cool&#x27;, beans: [&#x27;pinto&#x27;, &#x27;garbanzo&#x27;]};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.botkit.sparkbot" id="apidoc.element.botkit.sparkbot">
        function <span class="apidocSignatureSpan">botkit.</span>sparkbot
        <span class="apidocSignatureSpan">(configuration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Sparkbot(configuration) {

    // Create a core botkit bot
    var controller = Botkit(configuration || {});

    if (!controller.config.ciscospark_access_token) {
        throw new Error(&#x27;ciscospark_access_token required to create controller&#x27;);
    } else {
        controller.api = require(&#x27;ciscospark&#x27;).init({
            credentials: {
                authorization: {
                    access_token: controller.config.ciscospark_access_token
                }
            }
        });

        if (!controller.api) {
            throw new Error(&#x27;Could not create Cisco Spark API&#x27;);
        }

        controller.api.people.get(&#x27;me&#x27;).then(function(identity) {
            console.log(&#x27;Cisco Spark: My identity is&#x27;, identity);
            controller.identity = identity;
        }).catch(function(err) {
            throw new Error(err);
        });
    }

    if (!controller.config.public_address) {
        throw new Error(&#x27;public_address parameter required to receive webhooks&#x27;);
    } else {

        var endpoint = url.parse(controller.config.public_address);
        if (!endpoint.hostname) {
            throw new Error(&#x27;Could not determine hostname of public address: &#x27; + controller.config.public_address);
        } else if (endpoint.protocol != &#x27;https:&#x27;) {
            throw new Error(&#x27;Please specify an SSL-enabled url for your public address: &#x27; + controller.config.public_address);
        } else {
            controller.config.public_address = endpoint.hostname + (endpoint.port ? &#x27;:&#x27; + endpoint.port : &#x27;&#x27;);
        }

    }

    if (!controller.config.secret) {
        console.log(&#x27;WARNING: No secret specified. Source of incoming webhooks will not be validated. https://developer.ciscospark
.com/webhooks-explained.html#auth&#x27;);
        // throw new Error(&#x27;secret parameter required to secure webhooks&#x27;);
    }


    controller.resetWebhookSubscriptions = function() {
        controller.api.webhooks.list().then(function(list) {
            for (var i = 0; i &#x3c; list.items.length; i++) {
                controller.api.webhooks.remove(list.items[i]).then(function(res) {
                    console.log(&#x27;Removed subscription: &#x27; + list.items[i].name);
                }).catch(function(err) {
                    console.log(&#x27;Error removing subscription:&#x27;, err);
                });
            }
        });
    };

    // set up a web route for receiving outgoing webhooks and/or slash commands
    controller.createWebhookEndpoints = function(webserver, bot, cb) {


        var webhook_name = controller.config.webhook_name || &#x27;Botkit Firehose&#x27;;

        controller.log(
            &#x27;** Serving webhook endpoints for Cisco Spark Platform at: &#x27; +
            &#x27;http://&#x27; + controller.config.hostname + &#x27;:&#x27; + controller.config.port + &#x27;/ciscospark/receive&#x27;);
        webserver.post(&#x27;/ciscospark/receive&#x27;, function(req, res) {

            controller.handleWebhookPayload(req, res, bot);

        });


        var list = controller.api.webhooks.list().then(function(list) {
            var hook_id = null;

            for (var i = 0; i &#x3c; list.items.length; i++) {
                if (list.items[i].name == webhook_name) {
                    hook_id = list.items[i].id;
                }
            }

            var hook_url = &#x27;https://&#x27; + controller.config.public_address + &#x27;/ciscospark/receive&#x27;;

            console.log(&#x27;Cisco Spark: incoming webhook url is &#x27;, hook_url);

            if (hook_id) {
                controller.api.webhooks.update({
                    id: hook_id,
                    resource: &#x27;all&#x27;,
                    targetUrl: hook_url,
                    event: &#x27;all&#x27;,
                    secret: controller.config.secret,
                    name: webhook_name,
                }).then(function(res) {
                    console.log(&#x27;Cisco Spark: SUCCESSFULLY UPDATED CISCO SPARK WEBHOOKS&#x27;);
                    if (cb) cb();
                }).catch(function(err) {
                    console.log(&#x27;FAILED TO REGISTER WEBHOOK&#x27;, err);
                    throw new Error(err);
                });

            } else { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
This will configure your bot to respond only to messages from members of the specific organization, or whose email addresses match
 one of the specified domains.

The full code for a simple Cisco Spark bot is below:

```
var Botkit = require(&#x27;./lib/Botkit.js&#x27;);

var controller = Botkit.<span class="apidocCodeKeywordSpan">sparkbot</span>({
    debug: true,
    log: true,
    public_address: process.env.public_address,
    ciscospark_access_token: process.env.access_token,
    secret: process.env.secret
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.botkit.twilioipmbot" id="apidoc.element.botkit.twilioipmbot">
        function <span class="apidocSignatureSpan">botkit.</span>twilioipmbot
        <span class="apidocSignatureSpan">(configuration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Twiliobot(configuration) {

    // Create a core botkit bot
    var twilio_botkit = Botkit(configuration || {});

    // customize the bot definition, which will be used when new connections
    // spawn!
    twilio_botkit.defineBot(function(botkit, config) {
        var bot = {
            type: &#x27;twilioipm&#x27;,
            botkit: botkit,
            config: config || {},
            utterances: botkit.utterances,
        };

        bot.startConversation = function(message, cb) {
            botkit.startConversation(this, message, cb);
        };

        bot.send = function(message, cb) {
            botkit.debug(&#x27;SEND &#x27;, message);

            if (bot.identity === null || bot.identity === &#x27;&#x27;) {
                bot.api.channels(message.channel).messages.create({
                    body: message.text,
                }).then(function(response) {
                    cb(null, response);
                }).catch(function(err) {
                    cb(err);
                });
            } else {
                bot.api.channels(message.channel).messages.create({
                    body: message.text,
                    from: bot.identity
                }).then(function(response) {
                    cb(null, response);
                }).catch(function(err) {
                    cb(err);
                });
            }
        };

        bot.reply = function(src, resp, cb) {
            var msg = {};

            if (typeof(resp) == &#x27;string&#x27;) {
                msg.text = resp;
            } else {
                msg = resp;
            }

            msg.user = src.user;
            msg.channel = src.channel;

            bot.say(msg, cb);
        };

        bot.autoJoinChannels = function() {
          bot.api.channels.list().then(function(full_channel_list) {
            if (bot.config.autojoin === true) {
                bot.channels = full_channel_list;
                bot.channels.channels.forEach(function(chan) {
                    bot.api.channels(chan.sid).members.create({
                        identity: bot.identity
                    }).then(function(response) {
                        botkit.debug(&#x27;added &#x27; +
                          bot.identity + &#x27; as a member of the &#x27; + chan.friendly_name);
                    }).fail(function(error) {
                        botkit.debug(&#x27;Couldn\&#x27;t join the channel: &#x27; +
                            chan.friendly_name + &#x27;: &#x27; + error);
                    });
                });
            } else if (bot.identity) {

                // load up a list of all the channels that the bot is currently

                bot.channels = {
                    channels: []
                };

                async.each(full_channel_list.channels, function(chan, next) {
                    bot.api.channels(chan.sid).members.list().then(function(members) {
                        for (var x = 0; x &#x3c; members.members.length; x++) {
                            if (members.members[x].identity == bot.identity) {
                                bot.channels.channels.push(chan);
                            }
                        }
                        next();
                    }).fail(function(error) {
                        botkit.log(&#x27;Error loading channel member list: &#x27;, error);
                        next();
                    });
                });
            }
        }).fail(function(error) {
            botkit.log(&#x27;Error loading channel list: &#x27; + error);
            // fails if no channels exist
            // set the channels to empty
            bot.channels = { channels: [] };
        });

      };

        bot.configureBotIdentity = function() {
            if (bot.identity !== null || bot.identity !== &#x27;&#x27;) {
                var userRespIter = 0;
                var existingIdentity = null;

                // try the get by identity thing
                bot.api.users(bot.identity).get().then(function(response) {
                    bot.autoJoinChannels();
                }).fail(function(error) {
                    // if not make the new user and se ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

To connect your bot to Twilio, [follow the instructions here](https://www.twilio.com/user/account/ip-messaging/getting-started).
You will need to collect 5 separate pieces of your API credentials. A step by step guide [can be found here](#getting-started).
Since you must *already be running* your Botkit app to fully configure your Twilio app, there is a bit of back-and-forth. It&#x27
;s ok! You can do it.

Here is the complete code for a basic Twilio bot:

```javascript
var Botkit = require(&#x27;botkit&#x27;);
var controller = Botkit.<span class="apidocCodeKeywordSpan">twilioipmbot</span>({
debug: false
})

var bot = controller.spawn({
TWILIO_IPM_SERVICE_SID: process.env.TWILIO_IPM_SERVICE_SID,
TWILIO_ACCOUNT_SID: process.env.TWILIO_ACCOUNT_SID,
TWILIO_API_KEY: process.env.TWILIO_API_KEY,
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
